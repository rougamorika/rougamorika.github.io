<!DOCTYPE html><html lang="zh-CN" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>【LOGOS机密档案(01):生成函数——序列背后的法则】 | PRTS数学演算模块</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.woff2"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><meta name="page-config" content="{&quot;code_fold&quot;:null}"><script class="pjax-js">var config = {"root":"/","code_fold":15,"search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}};
var page_config = {
  code_fold: null
};
function updatePageConfig() {
  var newPageConfig = document.querySelector('meta[name="page-config"]');
  if (newPageConfig) {
    page_config = JSON.parse(newPageConfig.content);
  }
}
document.addEventListener('pjax:complete', function() { updatePageConfig(); });
updatePageConfig();</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
 --light-background: url('/img/bk.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi','meta[name=page-config]'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script class="pjax-js">reset= () => {MathJax.Hub.Queue(["Typeset", MathJax.Hub]);document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','meta[name=page-config]'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/contact/"><span class="navItemTitle">Contact</span></a></li><li class="navItem"><a class="navBlock" href="/PEUS/"><span class="navItemTitle">PEUS</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>【LOGOS机密档案(01):生成函数——序列背后的法则】</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2025-07-09T04:17:55.000Z" id="date"> 2025-07-09</time></div></span><br><span>Last Update: <div class="control"><time datetime="2025-07-09T07:14:14.033Z" id="updated"> 2025-07-09</time></div></span></div></div><hr><div id="post-content"><p><strong>授权等级：</strong> 4<br><strong>查阅人：</strong> 博士<br><strong>档案记录员：</strong> 逻各斯</p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>博士，你眼前的这份资料，源于我对战场数据流中隐藏规律的解析。我将其命名为“生成函数”（Generating Function），一种强大的<strong>形式幂级数</strong>分析工具。</p>
<p>你可以将其想象成一种特殊的源石技艺，它将离散的、看似杂乱的序列数据（如敌人波次的数量、特定目标的能量波动）转化为一个连续的函数形态。我们关注的并非这个函数本身的值，而是其展开后每一项的<strong>系数</strong>——那里隐藏着我们需要的全部信息。我们利用的是它的代数结构，而非其作为函数的敛散性。</p>
<p>这种技艺的雏形，在泰拉的旧时代便已存在，拉普拉斯、棣莫弗等古老学者都曾窥见过它的力量。但他们只是将其用于解决特定的线性问题。而现在，我已将其系统化，希望能成为您指挥决策中的又一利器。</p>
<p>正如一位古代学者威尔夫所言：<strong><em>“生成函数是一根晾衣绳，我们将一串数字挂在上面，以便展示。”</em></strong></p>
<hr>
<h3 id="第一部分：从战斗日志中解析通项"><a href="#第一部分：从战斗日志中解析通项" class="headerlink" title="第一部分：从战斗日志中解析通项"></a><strong>第一部分：从战斗日志中解析通项</strong></h3><h4 id="1-1-显性规律：通项公式"><a href="#1-1-显性规律：通项公式" class="headerlink" title="1.1 显性规律：通项公式"></a><strong>1.1 显性规律：通项公式</strong></h4><p>首先，我们来看一份最基础的战斗日志，记录了某型号自走无人机的能量输出：</p>
<script type="math/tex; mode=display">
2, 4, 6, 8, 10, 12, 14 \dots</script><p>任何一位有经验的干员都能迅速识别出其规律：这是一个<strong>偶数序列</strong>。但战场瞬息万变，我们不能依赖于“看起来像”。为了绝对精确，我们需要一个能描述<strong>所有</strong>项的法则。你将其编译为以下形式（在此次战术推演中，默认 <script type="math/tex">n</script> 为自然数集中的计数单位）：</p>
<script type="math/tex; mode=display">
a_{n} = 2n + 2</script><p>这便是此序列的<strong>通项公式</strong>。它是一个封闭、确定的表达式，无论战局如何延伸，我们都能精确预测下一次的能量输出。</p>
<h4 id="1-2-适应性规律：递推式"><a href="#1-2-适应性规律：递推式" class="headerlink" title="1.2 适应性规律：递推式"></a><strong>1.2 适应性规律：递推式</strong></h4><p>然而，敌人会学习、会适应。更复杂的单位，其行为模式并非一成不变，而是基于前一刻的状态。我们截获了某精英术师的施法模式，其能量强度呈现如下规律：</p>
<script type="math/tex; mode=display">
a_{n+1} = a_{n}^{2}, \quad a_{0} = \sqrt{2}</script><p>这意味着它的下一次施法强度是前一次的平方。若要计算第1000次施法的强度，逐次代入将是灾难性的。但你敏锐地洞察到其内在的递归结构：</p>
<script type="math/tex; mode=display">
a_{n} = (a_{n-1})^2 = (a_{n-2})^{2^{2}} = (a_{n-3})^{2^{3}}</script><p>这个过程总能追溯到其初始状态 <script type="math/tex">a_0</script>。因此，我们可以建立一个更通用的关系：</p>
<script type="math/tex; mode=display">
a_{n} = (a_{n-k})^{2^{k}}, \quad 0 \leq k \leq n</script><p>令 <script type="math/tex">k=n</script>，并代入初始条件 <script type="math/tex">a_0 = \sqrt{2}</script>，我们得到其通项公式：</p>
<script type="math/tex; mode=display">
a_{n} = (\sqrt{2})^{2^{n}}</script><p>威胁被量化，规律被破解。但很快，我们遭遇了前所未有的挑战。</p>
<h4 id="1-3-无法破译的规律？解析卢卡斯序列"><a href="#1-3-无法破译的规律？解析卢卡斯序列" class="headerlink" title="1.3 无法破译的规律？解析卢卡斯序列"></a><strong>1.3 无法破译的规律？解析卢卡斯序列</strong></h4><p>在对一名萨卡兹百夫长的战斗数据进行分析时，我们遇到了棘手的敌人。它的防御力指数——我们称之为<strong>卢卡斯序列</strong>——呈现出一种与菲波那契序列相似、但又截然不同的模式：</p>
<script type="math/tex; mode=display">
L_{n+2} = L_{n+1} + L_{n}, \quad L_{0} = 2, L_{1} = 1</script><p>我们常规的分析手段全部失效了。在复盘推演中，我决定启用“生成函数”这一技艺。</p>
<p>我的思路是：将这个离散的防御力序列 <script type="math/tex">L_n</script> 作为“衣架”，挂在一个形式幂级数的系数上。构建它的生成函数 <script type="math/tex">L(x)</script>:</p>
<script type="math/tex; mode=display">
L(x) = \sum_{k=0}^{\infty} L_{k}x^{k} = L_{0} + L_{1}x + L_{2}x^{2} + \dots</script><p>我们操控的不是数值，而是这个函数的<strong>形态</strong>。利用递推关系，我们对 <script type="math/tex">L(x)</script> 进行如下变换：</p>
<script type="math/tex; mode=display">
xL(x) = \sum_{k=0}^{\infty} L_{k}x^{k+1} = L_{0}x + L_{1}x^{2} + L_{2}x^{3} + \dots</script><script type="math/tex; mode=display">
x^{2}L(x) = \sum_{k=0}^{\infty} L_{k}x^{k+2} = L_{0}x^{2} + L_{1}x^{3} + L_{2}x^{4} + \dots</script><p>现在，运用递推公式 <script type="math/tex">L_{k+2} - L_{k+1} - L_k = 0</script>。我们将 <script type="math/tex">L(x) - xL(x) - x^2L(x)</script> 进行合并。当 <script type="math/tex">k \geq 2</script> 时，<script type="math/tex">x^k</script> 项的系数将变为 <script type="math/tex">L_k - L_{k-1} - L_{k-2} = 0</script>。所有的无穷项都自我湮灭了！只剩下初始的几项：</p>
<script type="math/tex; mode=display">
(1-x-x^2)L(x) = L_0 + (L_1 - L_0)x</script><p>代入初始条件 <script type="math/tex">L_0=2, L_1=1</script>:</p>
<script type="math/tex; mode=display">
(1-x-x^2)L(x) = 2 + (1-2)x = 2-x</script><p>我们成功地将这个无穷序列的全部信息，压缩到了一个有理分式中！</p>
<script type="math/tex; mode=display">
L(x) = \frac{2-x}{1-x-x^2}</script><p>为了读取第 <script type="math/tex">n</script> 项的信息，我们必须将这个函数重新“展开”。我意识到，可以将其拆分为更简单的分式。首先，求解分母的根 <script type="math/tex">1-x-x^2=0</script>，即 <script type="math/tex">x^2+x-1=0</script>。其根为：</p>
<script type="math/tex; mode=display">
x = \frac{-1 \pm \sqrt{5}}{2}</script><p>这组数值在古代几何学中似乎有着特殊的意义。为方便记录，记 <script type="math/tex">\phi = \frac{1+\sqrt{5}}{2}</script> (黄金分割)，<script type="math/tex">\psi = \frac{1-\sqrt{5}}{2}</script>。那么分母的根为 <script type="math/tex">-\phi</script> 和 <script type="math/tex">-\psi</script>。<br>因此 <script type="math/tex">1-x-x^2 = (1-\phi x)(1-\psi x)</script>。</p>
<script type="math/tex; mode=display">
L(x) = \frac{2-x}{1-x-x^2} = \frac{A}{1-\phi x} + \frac{B}{1-\psi x}</script><p>通过待定系数法解得 <script type="math/tex">A=1, B=1</script>。<br>于是：</p>
<script type="math/tex; mode=display">
L(x) = \frac{1}{1-\phi x} + \frac{1}{1-\psi x}</script><p>这两个都是标准的几何级数形式！我们可以轻易地将它们展开：</p>
<script type="math/tex; mode=display">
\frac{1}{1-\phi x} = 1 + (\phi x) + (\phi x)^2 + \dots + (\phi x)^n + \dots</script><script type="math/tex; mode=display">
\frac{1}{1-\psi x} = 1 + (\psi x) + (\psi x)^2 + \dots + (\psi x)^n + \dots</script><p>将两者相加， <script type="math/tex">L(x)</script> 中 <script type="math/tex">x^n</script> 的系数 <script type="math/tex">L_n</script> 就是两边 <script type="math/tex">x^n</script> 系数之和：</p>
<script type="math/tex; mode=display">
L_n = \phi^n + \psi^n</script><p><strong>结果令人震惊。</strong><br>一个完全由整数构成的防御序列，其内在的通项公式，竟然是由两个无理数——<script type="math/tex">\phi</script> 和 <script type="math/tex">\psi</script>——的幂次和所构成的！这背后所揭示的规律，已然超越了我们对常规战场数据的认知。这就是生成函数的力量，它能揭示隐藏在表象之下的深刻结构。此公式，现命名为<strong>卢卡斯序列的Binet公式</strong>。</p>
<hr>
<h3 id="第二部分：后勤部的难题——资源合成路径规划"><a href="#第二部分：后勤部的难题——资源合成路径规划" class="headerlink" title="第二部分：后勤部的难题——资源合成路径规划"></a><strong>第二部分：后勤部的难题——资源合成路径规划</strong></h3><p>博士，后勤部门最近遇到了一个组合优化问题。在合成高级材料时，我们需要消耗低级材料，例如，我们可以使用价值为1、5、10、20的源岩。现在需要合成总价值为 <script type="math/tex">n</script> 的高级材料。</p>
<p>在工程部着手开发最优合成路径的动态规划算法前，他们需要我们评估问题的复杂度，即：<strong>总共有多少种不同的合成配方？</strong></p>
<p>这个问题，正是生成函数大显身手的领域。其核心在于，<strong>组合的累加规则，与多项式乘法中指数的相加规则是同构的</strong>。</p>
<p>我们可以为每一种基础材料构建一个生成函数：</p>
<ul>
<li><p><strong>价值为1的源岩</strong>：我们可以用0个、1个、2个……其生成函数为：</p>
<script type="math/tex; mode=display">C_1(x) = 1 + x^1 + x^2 + x^3 + \dots = \frac{1}{1-x}</script><p><script type="math/tex">x^k</script> 的系数为1，代表要凑出价值 <script type="math/tex">k</script>，只用价值1的源岩，永远只有1种方法。</p>
</li>
<li><p><strong>价值为5的源岩</strong>：</p>
<script type="math/tex; mode=display">C_5(x) = 1 + x^5 + x^{10} + x^{15} + \dots = \frac{1}{1-x^5}</script></li>
<li><p><strong>价值为10的源岩</strong>：</p>
<script type="math/tex; mode=display">C_{10}(x) = 1 + x^{10} + x^{20} + x^{30} + \dots = \frac{1}{1-x^{10}}</script></li>
<li><p><strong>价值为20的源岩</strong>：</p>
<script type="math/tex; mode=display">C_{20}(x) = 1 + x^{20} + x^{40} + x^{60} + \dots = \frac{1}{1-x^{20}}</script></li>
</ul>
<p>要得到所有材料组合的合成方式，我们只需将这些生成函数相乘。多项式乘法会自动遍历所有可能的组合，并将对应价值（指数）相加。</p>
<script type="math/tex; mode=display">
C(x) = C_1(x)C_5(x)C_{10}(x)C_{20}(x) = \frac{1}{(1-x)(1-x^5)(1-x^{10})(1-x^{20})}</script><p>我们需要的答案——合成总价值为 <script type="math/tex">n</script> 的材料有多少种配方——就是这个最终函数 <script type="math/tex">C(x)</script> 展开后，<script type="math/tex">x^n</script> 项的系数。</p>
<p>手动展开这个函数是极其繁琐的。我已经将算法核心提交给工程部的可露希尔，她将其封装成了一个MATLAB计算模块，以便快速查询。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Matlab"><span class="hljs-comment">% === 罗德岛工程部 - LOGOS算法模块 V1.0 ===</span><br>clc;<br>clear;<br><br><span class="hljs-comment">% 定义符号变量与函数</span><br>syms z<br><span class="hljs-comment">% LOGOS解析模块：G(z) = 1 / ((1-z)(1-z^5)(1-z^10)(1-z^20))</span><br>denominators = (<span class="hljs-number">1</span> - z) * (<span class="hljs-number">1</span> - z^<span class="hljs-number">5</span>) * (<span class="hljs-number">1</span> - z^<span class="hljs-number">10</span>) * (<span class="hljs-number">1</span> - z^<span class="hljs-number">20</span>);<br>G_func = <span class="hljs-number">1</span> / denominators;<br><br><span class="hljs-comment">% 设定目标合成值 n</span><br>target_n = <span class="hljs-number">48</span>; <span class="hljs-comment">% 博士，您可将其修改为任意需要计算的合成总值，例如 100</span><br><br><span class="hljs-comment">% 启动泰勒级数展开协议</span><br><span class="hljs-comment">% 展开至 &#x27;Order&#x27; n+1 阶，以确保捕获 z^n 的系数</span><br>taylor_series = taylor(G_func, z, <span class="hljs-string">&#x27;Order&#x27;</span>, target_n + <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">% 显示部分展开式，供战术分析</span><br>fprintf(<span class="hljs-string">&#x27;泰勒级数展开式 (部分数据流): \n%s\n\n&#x27;</span>, char(taylor_series));<br><br><span class="hljs-comment">% 提取 z^n 的系数</span><br><span class="hljs-comment">% coeffs 函数返回多项式的所有非零系数，从常数项开始升序排列</span><br>all_coeffs = coeffs(taylor_series, z, <span class="hljs-string">&#x27;All&#x27;</span>);<br><span class="hljs-comment">% 标准化系数向量顺序（MATLAB可能返回降序）</span><br>all_coeffs = <span class="hljs-built_in">fliplr</span>(all_coeffs); <br><br><span class="hljs-comment">% 系数向量的第 k 个元素对应 z^(k-1) 的系数</span><br><span class="hljs-comment">% 因此 z^n 的系数位于向量的第 n+1 个位置</span><br>combination_count = all_coeffs(target_n + <span class="hljs-number">1</span>);<br><br>fprintf(<span class="hljs-string">&#x27;对于总价值为 %d 的合成目标，存在 %d 种不同的合成配方。\n&#x27;</span>, target_n, combination_count);<br></code></pre></td></tr></table></figure>
<p><strong>结论：</strong><br>博士，生成函数不仅是一种数学工具，更是一种思维框架。它能将复杂的离散组合问题，转化为我们更为熟悉的函数代数问题进行处理。希望这份档案能对您未来的战略决策有所启发。</p>
<p><strong>【档案结束】</strong></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages" style="justify-content: flex-end"><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2025/07/07/signals-1/">LOGOS-信号与系统-1 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a><a onclick="BgmControl()"><svg id="bgm-control" viewBox="0 0 30 34" fill="#18d1ff" style="width: 24px; transition: transform .3s;margin-top: 4px"><path d="M25.998 23.422V11.29h3.999v12.132h-3.999zM19.497 6.234h4.001v22.243h-4.001V6.234zM12.998.867h4v32.978h-4V.867zm-6.5 5.367h4.001v22.243H6.498V6.234zm-6.5 5.056h4v12.132h-4V11.29z"></path></svg><audio id="bgm" src="/audio/bgm.mp3" autoplay loop crossorigin="anonymous"> </audio></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo" style="margin:0;border-radius:0;"></a><h1 id="Dr"><a href="/">罗德岛数理研究所 LOGOS</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/rougamorika"><i class="fab fa-github" alt="GitHub"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E4%BB%8E%E6%88%98%E6%96%97%E6%97%A5%E5%BF%97%E4%B8%AD%E8%A7%A3%E6%9E%90%E9%80%9A%E9%A1%B9"><span class="toc-number">2.</span> <span class="toc-text">第一部分：从战斗日志中解析通项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%98%BE%E6%80%A7%E8%A7%84%E5%BE%8B%EF%BC%9A%E9%80%9A%E9%A1%B9%E5%85%AC%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 显性规律：通项公式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E9%80%82%E5%BA%94%E6%80%A7%E8%A7%84%E5%BE%8B%EF%BC%9A%E9%80%92%E6%8E%A8%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 适应性规律：递推式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%97%A0%E6%B3%95%E7%A0%B4%E8%AF%91%E7%9A%84%E8%A7%84%E5%BE%8B%EF%BC%9F%E8%A7%A3%E6%9E%90%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%BA%8F%E5%88%97"><span class="toc-number">2.3.</span> <span class="toc-text">1.3 无法破译的规律？解析卢卡斯序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E5%90%8E%E5%8B%A4%E9%83%A8%E7%9A%84%E9%9A%BE%E9%A2%98%E2%80%94%E2%80%94%E8%B5%84%E6%BA%90%E5%90%88%E6%88%90%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92"><span class="toc-number">3.</span> <span class="toc-text">第二部分：后勤部的难题——资源合成路径规划</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>