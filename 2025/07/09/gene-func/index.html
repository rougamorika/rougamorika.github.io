<!DOCTYPE html><html lang="zh-CN" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>LOGOStoolbox-生成函数(1) | PRTS数学演算模块</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.woff2"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><meta name="page-config" content="{&quot;code_fold&quot;:null}"><script class="pjax-js">var config = {"root":"/","code_fold":15,"search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}};
var page_config = {
  code_fold: null
};
function updatePageConfig() {
  var newPageConfig = document.querySelector('meta[name="page-config"]');
  if (newPageConfig) {
    page_config = JSON.parse(newPageConfig.content);
  }
}
document.addEventListener('pjax:complete', function() { updatePageConfig(); });
updatePageConfig();</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
 --light-background: url('/img/bk.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi','meta[name=page-config]'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script class="pjax-js">reset= () => {MathJax.Hub.Queue(["Typeset", MathJax.Hub]);document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','meta[name=page-config]'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/contact/"><span class="navItemTitle">Contact</span></a></li><li class="navItem"><a class="navBlock" href="/PEUS/"><span class="navItemTitle">PEUS</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>LOGOStoolbox-生成函数(1)</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2025-07-09T04:17:55.000Z" id="date"> 2025-07-09</time></div></span><br><span>Last Update: <div class="control"><time datetime="2025-07-09T06:50:52.013Z" id="updated"> 2025-07-09</time></div></span></div></div><hr><div id="post-content"><h2 id="生成函数的发展史"><a href="#生成函数的发展史" class="headerlink" title="生成函数的发展史"></a>生成函数的发展史</h2><p>生成函数(Generating Function),有的时候也叫做母函数,是一种<strong>形式幂级数</strong>.也就是说,它就是长成幂级数的样子,但是我们不用考虑幂级数的敛散性.形式幂级数可以讨论其环结构和拓扑结构.但是我们这里不介绍(有待LOGOS解析完毕后再介绍).</p>
<p>母函数最早由P.S.Laplace命名,但是其实比他更早的 De Moivre 就已经提出了母函数的概念并广泛地解决一般的线性重复问题.其实Euler和Bernoulli的时代大家就已经不加命名与解释地使用母函数来组合分析和数论问题.所以我们也将从他们的案例出发介绍这个工具,以便各位博士能够更好地应用这个工具解决PEUS中遇到的敌人.</p>
<p>引用Wlif先生的一句名言:<strong><em>A generating function is a clothesline on which we hang up a sequence of numbers for display.</em></strong></p>
<h2 id="生成函数在求解数列通项上的使用"><a href="#生成函数在求解数列通项上的使用" class="headerlink" title="生成函数在求解数列通项上的使用"></a>生成函数在求解数列通项上的使用</h2><h3 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h3><p>首先我们来看一个数列</p>
<script type="math/tex; mode=display">
2,4,6,8,10,12,14\dots</script><p>细心的同志可能会觉得,这不就是<strong>偶数序列</strong>嘛.可是如果省略号中有不是偶数的数,那么我们就不能称它是偶数序列.所以,为绝后患,你将这个序列写成了下面的形式.(在今天的讨论中,默认$n$是自然数集的元素)</p>
<script type="math/tex; mode=display">
a_{n}=2n+2</script><p>这下大家都皆大欢喜了,很高兴地将上面的函数叫做数列的<strong>通项公式</strong>.</p>
<h3 id="递推式"><a href="#递推式" class="headerlink" title="递推式"></a>递推式</h3><p>LOGOS的同志喜欢搞抽象,每一次都得找出数列的特征太麻烦了.有些时候我只能知道这个<strong>数列部分的特性</strong>,能不能也找出数列的规律呢?<br>这个当然可以,只要数列所有之后的特性都可以由前面已知的信息推导出来就可以了嘛!于是我们讨论了下面这个序列</p>
<script type="math/tex; mode=display">
a_{n+1}=a_{n}^{2},a_{0}=\sqrt{2}</script><p>那么这个时候我们要怎么求出通项公式呢?如果一次一次带入求$a_{1000}$将是极其复杂的.此时聪明的你注意到</p>
<script type="math/tex; mode=display">
a_{n}=(a_{n-1})^2=(a_{n-2})^{2^{2}}=(a_{n-3})^{2^{3}}</script><p>总是能递归到<script type="math/tex">n=0</script>的,于是你将上面的改写</p>
<script type="math/tex; mode=display">
(a_{n})^{2^{0}}=(a_{n-1})^{2^{1}}=(a_{n-2})^{2^{2}}=(a_{n-3})^{2^{3}}</script><p>所以你得到</p>
<script type="math/tex; mode=display">
a_{n}=(a_{n-k})^{2^{k}},0\leq k\leq n</script><p>带入<script type="math/tex">k=n</script>和初始条件得到</p>
<script type="math/tex; mode=display">
a_{n}=(\sqrt{2})^{2^{n}}</script><p>恭喜你得到了封闭形式!但是你发现你的快乐到此为止了.</p>
<h3 id="这是可以计算的-Lucas-数列"><a href="#这是可以计算的-Lucas-数列" class="headerlink" title="这是可以计算的? Lucas 数列"></a>这是可以计算的? Lucas 数列</h3><p>LOGOS的众人们解决了这个问题,但是很快发现他们的工具箱不够用了,隆重介绍:<strong>Lucas 数列</strong>.<br>Lucas 数列是为了解决 Fibonacci 数列而引入的一种新的数列,它和 Fibonacci 数列极其相似,只有初值不同.</p>
<script type="math/tex; mode=display">
L_{n+2}=L_{n+1}+L_{n},L_{0}=2,L_{1}=1</script><p>LOGOS的同志发现自己对这样的数列根本就没有思路,行动失败了.在复盘的时候,他们发现了这样的一种工具.<br>假如我们将 Lucas 数列的每一项都变成成一个幂级数对应的系数,那么我们就可以用<strong>处理幂级数的方法来处理 Lucas 数列</strong>.我们可以这样写我们的幂级数</p>
<script type="math/tex; mode=display">
L(x)=\sum_{k=0}^{\infty}L_{k}x^{k}=L_{0}+L_{1}x+L_{2}x^{2}+\dots</script><p>而我们无需考虑幂级数的敛散性,因为我们关注的是系数而不是幂级数的值,我们只是借用幂级数的形式.<br>那么我们可以作如下的处理,首先我们可以得到</p>
<script type="math/tex; mode=display">
xL(x)=\sum_{k=0}^{\infty}L_{k}x^{k+1}=L_{0}x+L_{1}x^{2}+L_{2}x^{3}+\dots</script><script type="math/tex; mode=display">
x^{2}L(x)=\sum_{k=0}^{\infty}L_{k}x^{k+1}=\ L_{0}x^{2}+L_{1}x^{3}+L_{2}x^{4}+\dots</script><p>为了能够用上Lucas递推数列的性质,我们用下面的两个式子相加减去第一个式子,则右侧所有$x^{2}$以上的项目都可以消去得到下面的简单表达</p>
<script type="math/tex; mode=display">
(x^{2}+x-1)L(x)=(L_{0}-L_{1})x-L_{0}</script><p>由于已知初始条件,带入可得</p>
<script type="math/tex; mode=display">
(x^{2}+x-1)L(x)=x-2</script><p>即</p>
<script type="math/tex; mode=display">
L(x)=\frac{x-2}{x^{2}+x-1}</script><p>看到这里,LOGOS解出这个<strong>形式幂级数的封闭形式!</strong> 可是通项是系数的通项,所以还得将其展开,但是这次要求其系数的封闭形式.LOGOS凭借自己的经验,意识到,有理分式函数可以拆解成多个分式函数的和.首先要对下面的方程式因式分解.注意到下面的两个解分别为</p>
<script type="math/tex; mode=display">
x=\frac{-1\pm \sqrt{5}}{2}</script><p>这太难写了,我们就记正的为$\Phi$,负的为$\Psi$,我们可以得出</p>
<script type="math/tex; mode=display">
\frac{x-2}{x^{2}+x-1}=\frac{a}{x-\Phi}+\frac{b}{x-\Psi}</script><p>只要求解上面的方程就可以了</p>
<script type="math/tex; mode=display">
x-2=a(x-\Psi)+b(x-\Phi)=(a+b)x-a\Psi-b\Phi</script><p>对应得出二元方程</p>
<script type="math/tex; mode=display">
a=\frac{1-\sqrt{5}}{2}=-\Phi,b=\frac{1+\sqrt{5}}{2}=-\Psi</script><p>所以我们可以写成</p>
<script type="math/tex; mode=display">
\frac{x-2}{x^{2}+x-1}=\frac{-\Phi}{x-\Phi}+\frac{-\Psi}{x-\Psi}=\frac{1}{1-\frac{x}{\Phi}}+\frac{1}{1-\frac{x}{\Psi}}</script><p>所以后两者都是幂函数的幂级数,自然可以展开</p>
<script type="math/tex; mode=display">
\frac{1}{1-\frac{x}{\Phi}}=1+\frac{x}{\Phi}+\frac{x^{2}}{\Phi^{2}}+\dots+\frac{x^{n}}{\Phi^{n}}</script><script type="math/tex; mode=display">
\frac{1}{1-\frac{x}{\Psi}}=1+\frac{x}{\Psi}+\frac{x^{2}}{\Psi^{2}}+\dots+\frac{x^{n}}{\Psi^{n}}</script><p>所以注意到</p>
<script type="math/tex; mode=display">
L_{n}=\Phi^{-n}+\Psi^{-n}</script><p><strong><em>什么?!!!!!!!!!!!!!</em></strong><br>一个全是整数的数列的通项公式竟然是两个无理数的和!!!这是怎么样都想不到啊.<br>上面的公式,现在我们叫它 <strong>Lucas 数列的 Binet 公式</strong></p>
<h3 id="利用生成函数解决找零问题"><a href="#利用生成函数解决找零问题" class="headerlink" title="利用生成函数解决找零问题"></a>利用生成函数解决找零问题</h3><p>LOGOS 发现在有些地区还在使用传统的理智值进行交易,许多人都会去理智值小卖部购买相关的商品/装备,理智值的小面值有1点,5点,10点和20点.许多人并不会直接给你凑好的理智值,他们会给你一张大面值的理智值兑换券,比如100点的,你必须要找零.作为小卖部的老板总是不希望自己的零钱用完以至于无法做生意,老板希望LOGOS的组员帮助他解决这个找零的问题.<br>形式化的,即给定一个输入<script type="math/tex">n</script>,已知<script type="math/tex">x=1,y=5,z=10,w=20</script>,试解决下面的最优化问题</p>
<script type="math/tex; mode=display">
    ax+by+cz+dw=n,\text{最小化}\quad m=a+b+c+d</script><p>LOGOS当中的算法部门选择使用动态规划来解决这样的问题,他们完成了一个程序.在此之前,他们需要我们解决一个前置问题,那就是<strong>数据量到底有多大</strong>?<br>形式化地说,他们需要我们求出<strong>所有满足分拆条件的拆分方式的种类数</strong></p>
<p>我们可以用生成函数来解决这个问题,这是因为生成函数的本质是多项式的指数相加规则和组合累加规则是同构的.我们可以这样来看:<br>首先是使用一点的理智值,每多用一点我们就让多项式的指数加<script type="math/tex">1</script>,所以我们可以知道如果都用1点,我们的生成函数就会长成这样:</p>
<script type="math/tex; mode=display">
C_{1}(x)=1+x+x^{2}+x^{3}+...</script><p>此时多项式的系数就表示我们描述这个钱币和的种类数,显然如果我们只用<script type="math/tex">1</script>理智值的钱币,无论什么面值的找零都只有一种方式,那就是<script type="math/tex">n</script>个<script type="math/tex">1</script>.<br>不妨来看面值为<script type="math/tex">5</script>的情况</p>
<script type="math/tex; mode=display">
C_{5}(x)=1+x^{5}+x^{10}+x^{15}+...</script><p>同样的这也贡献了一些找零的方法.那么我们怎么找钱呢.比如找您12点理智,还记得理智的加法是作用在指数上的嘛,<strong>指数相加就意味着这两个幂函数相乘</strong>.因此,只要将<script type="math/tex">C_{1}(x)</script>和<script type="math/tex">C_{5}(x)</script>乘在一起,我们就得到了所有的取法(因为多项式乘法是每个都要乘的,相当于遍历所有组合形式).<br>同理,我们只要写出</p>
<script type="math/tex; mode=display">
C_{10}(x)=1+x^{10}+x^{20}+x^{30}+...</script><script type="math/tex; mode=display">
C_{20}(x)=1+x^{20}+x^{40}+x^{60}+...</script><p>然后求得</p>
<script type="math/tex; mode=display">
C(x)=C_{1}(x)C_{5}(x)C_{10}(x)C_{20}(x)</script><p>中<script type="math/tex">x^{n}</script>的系数即可</p>
<p>很显然,利用形式幂级数,我们还是可以写出</p>
<script type="math/tex; mode=display">
C(x)=\frac{1}{(1-x)(1-x^{5})(1-x^{10})(1-x^{20})}</script><p>现在,只要展开它就可以了(累),交给Matlab吧</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">clc;<br>clear;<br><span class="hljs-comment">% 定义符号变量与函数</span><br>syms z<br><span class="hljs-comment">% G(z) = 1 / ((1-z)(1-z^5)(1-z^10)(1-z^20))</span><br>denominators = (<span class="hljs-number">1</span> - z) * (<span class="hljs-number">1</span> - z^<span class="hljs-number">5</span>) * (<span class="hljs-number">1</span> - z^<span class="hljs-number">10</span>) * (<span class="hljs-number">1</span> - z^<span class="hljs-number">20</span>);<br>G_func = <span class="hljs-number">1</span> / denominators;<br><span class="hljs-comment">% 设定目标</span><br>target_n = <span class="hljs-number">48</span>; <span class="hljs-comment">% 您可以改成任何您想计算的数, 比如 100</span><br><span class="hljs-comment">% 将生成函数展开</span><br><span class="hljs-comment">% 我们需要展开到 &#x27;Order&#x27; n+1 才能得到 z^n 的系数</span><br>taylor_series = taylor(G_func, z, <span class="hljs-string">&#x27;Order&#x27;</span>, target_n + <span class="hljs-number">1</span>);<br><span class="hljs-comment">% 打印展开式的前面一部分，以供观察</span><br>fprintf(<span class="hljs-string">&#x27;泰勒级数展开式 (部分): \n%s\n\n&#x27;</span>, char(taylor_series));<br><span class="hljs-comment">% 5. 提取 z^n 的系数</span><br><span class="hljs-comment">% coeffs 函数返回多项式的所有系数，从常数项开始升序排列</span><br>all_coeffs = coeffs(taylor_series, z, <span class="hljs-string">&#x27;All&#x27;</span>);<br><span class="hljs-comment">% MATLAB 的符号系数可能是从高次项到低次项的，我们需要反转它</span><br><span class="hljs-comment">% &#x27;All&#x27; 参数保证了即使某一项为0，也会返回系数</span><br>all_coeffs = <span class="hljs-built_in">fliplr</span>(all_coeffs); <br><span class="hljs-comment">% 系数向量的第 k 个元素对应 z^(k-1) 的系数</span><br><span class="hljs-comment">% 所以 z^n 的系数在向量的第 n+1 个位置</span><br>combination_count = all_coeffs(target_n + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
<div id="paginator"></div></div><div id="post-footer"><div id="pages" style="justify-content: flex-end"><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2025/07/07/signals-1/">LOGOS-信号与系统-1 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a><a onclick="BgmControl()"><svg id="bgm-control" viewBox="0 0 30 34" fill="#18d1ff" style="width: 24px; transition: transform .3s;margin-top: 4px"><path d="M25.998 23.422V11.29h3.999v12.132h-3.999zM19.497 6.234h4.001v22.243h-4.001V6.234zM12.998.867h4v32.978h-4V.867zm-6.5 5.367h4.001v22.243H6.498V6.234zm-6.5 5.056h4v12.132h-4V11.29z"></path></svg><audio id="bgm" src="/audio/bgm.mp3" autoplay loop crossorigin="anonymous"> </audio></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo" style="margin:0;border-radius:0;"></a><h1 id="Dr"><a href="/">罗德岛数理研究所 LOGOS</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/rougamorika"><i class="fab fa-github" alt="GitHub"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">1.</span> <span class="toc-text">生成函数的发展史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%9C%A8%E6%B1%82%E8%A7%A3%E6%95%B0%E5%88%97%E9%80%9A%E9%A1%B9%E4%B8%8A%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">生成函数在求解数列通项上的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%A1%B9%E5%85%AC%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">通项公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E6%8E%A8%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">递推式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%AE%A1%E7%AE%97%E7%9A%84-Lucas-%E6%95%B0%E5%88%97"><span class="toc-number">2.3.</span> <span class="toc-text">这是可以计算的? Lucas 数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.</span> <span class="toc-text">利用生成函数解决找零问题</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>